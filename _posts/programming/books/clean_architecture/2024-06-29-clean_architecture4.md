---
title: "[Clean Architecture] CH4 구조적 프로그래밍"
layout: single
date: '29/06/2024'
toc: true
toc_sticky: true
toc_label: Table of Contents
categories:
  - BOOKS
tags:
  - BOOKS
---

---

### 증명
* Dikstra는 프로그래머가 입증된 구조를 이용해서 코드를 작성하면 코드가 올바르다다는 사실을 증명하고자 함
* 이 과정에서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견
* 반면 goto 문장을 사용하더라도 문제가 되지 않은 경우는 if/then/else(분기)와 do/while(반복)이라는 단순한 제어 구조에 해당하는 사실을 발견
* 이러한 구조가 순차 실행(sequential execution)과 결합했을 때 특별함을 발견
* Böhm과 Jacopinieh도 모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration)이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명

---

### 해로운 성명서
* Dikstra는 goto문의 해로움이라는 글을 썻으며, 이로 인해 프로그래밍 세계는 논쟁이 붙음
* 결과적으로, 컴퓨터 언어는 진화하면서 goto 문장은 사라지게 됨
* 현재의 모든 프로그램은 구조적 프로그래머임, 왜냐하면 제어흐름을 직접 전환할 수 있는 선택권 자체가 없기 때문

---

### 기능적 분해
* 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 됨
    * 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻함
* 즉, 거대한 문제를 받더라도 이를 고수준의 기능들로 분해할 수 있으며, 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있음
    * 이러한 분해 과정은 끝없이 반복될 수 있음
* 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있음

---

### 엄밀한 증명은 없었다
* 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않음
* 이에 대해 상당히 성공한 또 다른 전략은 과학적 방법(scientific method)가 존재

---

### 과학이 구출하다
* 과학 이론과 법칙은 수학과 달리 반증은 가능하지만 증명은 불가능함
* 하지만 현실에서 많은 부분은 이러한 법칙에 기반함(ex. 자동차를 탈 때마다 F=ma가 세상이 움직이는 방식을 설명하는 믿을 만한 법칙이라는데 생사를 검)
* 과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 `서술이 틀렸음을 증명하는 방식`으로 동작함
* 각고의 노력으로도 반례를 들 수 없는 서술은 목표에 부합할 만큼은 참인 것임

---

### 테스트
* 테스트를 통해 프로그램이 잘못되었음을 증명할 수 있지만, 프로그램이 맞다고 증명할 수는 없음
* 즉, 테스트에 충분한 노력을 들였다면, 테스트가 보장하는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부임
* 소프트웨어 개발은 이러한 점에서 수학적인 시도가 아니라 과학과 유사함
    * 왜냐하면 (테스트에) 최선을 다하더라도 올바라지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문
* 부정확함에 대한 증명은 입증 가능한 프로그램에서만 적용할 수 있음
    * 가령 제약 없는 goto 문을 사용한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르지 ㅇ낳음
* 구조적 프로그래밍은 프로그램을 증명한 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요
    * 이후 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도
    * 거짓임을 증명하려는 테스트가 실패하면 해당 기능들은 목표에 부합할 만큼은 충분히 참임

---

### 결론
* 구조적 프로그래밍이 오늘까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문
* 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 함
* 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도됨
* 소프트웨어 아키텍트는 `모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력`해야 함

---
